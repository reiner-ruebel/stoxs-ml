## Organization
When organizing a Flask-based web application, there are two main strategies for handling configurations: centralized or decentralized.

In the centralized approach, all configurations (like database settings, API keys, core functionalities such as mailing services) are grouped in a single place, such as a config.py or config.ini file. This strategy simplifies general configuration management but can make specific topic-focused work less intuitive.

Alternatively, the decentralized approach involves keeping related configurations near their respective functional areas, like having a distinct config.py for the database module. While this method can make working on specific areas more straightforward, it may lead to scattered configuration management.

The chosen structure should complement the application's overall architecture and the developer's workflow preferences.

For instance, an app divided into web, api, core, and shared modules might benefit from a consistent configuration approach across these subfolders to maintain clarity and organization. This is how the stoxs-ml application is organized.

Secret configurations like passwords for services or the location of the database are in one location, while other configurations are in the respective module's config.py file.

## Passowrd test
$ is not allowed, backslash is allowed.

## models
An HTTP request comes via post to a namespace class method: This is a payload model (example: register a user with username, password, firstname, ...)
The method is decorated with ns.expect(swagger_model) for documentation.
The method is decorated with ns.marshal_with(response_model) to send back to the client.
The data are stored in the database via a model class method: This is a database model (example: User with username, password, firstname, ...)

Payload data are validated using marshmallow. The marshmallow schema is defined in the payload model class. The marshmallow schema is used in the database model class to validate the data before storing them in the database.

The application is organized as in web.namespaces. Each module which contains a namespace will be registered.

There are payload models and response models. The payload models are used to validate the data which are sent to the server. The response models are used to validate the data which are sent back to the client.

There are Swagger models which will be created from the payload models. The Swagger models are used to document the API. The strings are in the swagger docu class.

DB models are in core.

## Utils
The app utils should not depend on anything within the app.


## Controllers
With dependency injection I follow the ASP.NET pattern (which I have seen for Python too): We have an interface like IAccountService (contains methods like register()). Then, there is (or there are multiple) impelmentations AccountTestService(IAccountService), AccountService(IAccountService) etc. There is provider in a Service class which derives from containers.DeclarativeContainer. flask-restx provides the service to define classes which get the (e.g. post) the request data to a post method. Together with the __init__ and a marshmallow validation / serialization a var of type RegisterPayload gets crated and the account_service's register method can be called with this payload. Now, the account_service will have some methods like register, change_password, .... but I can only serve one of these methods with a Resource class. I trust that the process is clear and I am lookig for naming conventions. In ASP.NET this is called controller. But the controller can have multiple post entries. What could a naming schema look like for such a scenario? 


## Documentation
core is responsible for documentation. Documentation is centralized in the web folder/shared
Data are centralized: easier to check / adjust documentation consistency, check spelling and the option for translation.

## Versions
Test different versions using namespaces. https://flask-restx.readthedocs.io/en/latest/scaling.html

## hierary:
We have a main.py file which is the starting point. The folders in app are thought of like projects with a certain hierachy.

web contains all web (i.e. flask in out case) related functionaliry and also defines the startup project: it should not be accessed from the other projects except for the main.py file.

The controllers in the controller folder are the entry points for the REST API. They are short and call the services.

services are the app services which contain the business logic. They are accessed by the controllers and can access the core.

core is the project with the library code, like mail, file handling, etc. Independent from the web project. It can be accessed by the other projects.

## Access
If we access modules, we should as a rule access only what is available in the containing package. If we access module in the same package, we should use relative imports.

## Documentation of the creation of the test controller
In the app/services folder we create a /test folder
In the test folder we create a test_service.py file and a itest_service.py interface file
The interface file contains the interface ITestService which contains the abstract methods which will be implemented in the test_service.py file
In the test_service.py file we create a class TestService which implements the ITestService interface

## dependency injection
we use depenny injection from the start so we do not have to call the service classes directly but we can use the interface classes. This is done in the main.py file.
in main.py we never have to use a different Program class if we are in dev mode. We have alternative implementations of the IProgram interface which we can adjust in the program_services module in app.program.